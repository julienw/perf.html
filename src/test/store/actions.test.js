/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

import { storeWithProfile } from '../fixtures/stores';
import * as ProfileViewSelectors from '../../reducers/profile-view';
import * as UrlStateSelectors from '../../reducers/url-state';
import { getProfileWithMarkers } from './fixtures/profiles';

import {
  changeCallTreeSearchString,
  changeHidePlatformDetails,
  addRangeFilter,
  changeInvertCallstack,
  updateProfileSelection,
  changeImplementationFilter,
} from '../../actions/profile-view';
import { changeFlameChartColorStrategy } from '../../actions/timeline';
import { getCategoryByImplementation } from '../../profile-logic/color-categories';

const { selectedThreadSelectors } = ProfileViewSelectors;

describe('selectors/getStackTimingByDepthForFlameChart', function() {
  /**
   * This table shows off how a flame chart gets filtered to JS only, where the number is
   * the stack index, and P is platform code, and J javascript.
   *
   *            Unfiltered             ->             JS Only
   *   0-10-20-30-40-50-60-70-80-90-91      0-10-20-30-40-50-60-70-80-90-91 <- Timing (ms)
   *  ================================     ================================
   *  0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |     0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |
   *  1P 1P 1P 1P    1P 1P 1P 1P 1P  |                       1J 1J 1J 1J  |
   *     2P 2P 3P       4J 4J 4J 4J  |                          2J 2J     |
   *                       5J 5J     |                             3P     |
   *                          6P     |                             4J     |
   *                          7P     |
   *                          8J     |
   */

  it('computes unfiltered stack timing by depth', function() {
    const store = storeWithProfile();
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(
      store.getState()
    );
    expect(stackTimingByDepth).toEqual([
      { start: [0], end: [91], stack: [0], length: 1 },
      { start: [0, 50], end: [40, 91], stack: [1, 1], length: 2 },
      { start: [10, 30, 60], end: [30, 40, 91], stack: [2, 3, 4], length: 3 },
      { start: [70], end: [90], stack: [5], length: 1 },
      { start: [80], end: [90], stack: [6], length: 1 },
      { start: [80], end: [90], stack: [7], length: 1 },
      { start: [80], end: [90], stack: [8], length: 1 },
    ]);
  });

  it('computes "Hide platform details" stack timing by depth', function() {
    const store = storeWithProfile();
    store.dispatch(changeHidePlatformDetails(true));
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(
      store.getState()
    );

    expect(stackTimingByDepth).toEqual([
      { start: [0], end: [91], stack: [0], length: 1 },
      { start: [60], end: [91], stack: [1], length: 1 },
      { start: [70], end: [90], stack: [2], length: 1 },
      { start: [80], end: [90], stack: [3], length: 1 },
      { start: [80], end: [90], stack: [4], length: 1 },
    ]);
  });

  it('uses search strings', function() {
    const store = storeWithProfile();
    store.dispatch(changeCallTreeSearchString('javascript'));
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(
      store.getState()
    );
    expect(stackTimingByDepth).toEqual([
      { start: [60], end: [91], stack: [0], length: 1 },
      { start: [60], end: [91], stack: [1], length: 1 },
      { start: [60], end: [91], stack: [4], length: 1 },
      { start: [70], end: [90], stack: [5], length: 1 },
      { start: [80], end: [90], stack: [6], length: 1 },
      { start: [80], end: [90], stack: [7], length: 1 },
      { start: [80], end: [90], stack: [8], length: 1 },
    ]);
  });

  /**
   * The inverted stack indices will not match this chart, as new indices will be
   * generated by the function that inverts the profile information.
   *
   *            Uninverted             ->             Inverted
   *   0-10-20-30-40-50-60-70-80-90-91      0-10-20-30-40-50-60-70-80-90-91 <- Timing (ms)
   *  ================================     ================================
   *  0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |     1P 2P 2P 3P 0P 1P 4J 5P 8J 4J
   *  1P 1P 1P 1P    1P 1P 1P 1P 1P  |     0P 1P 1P 1P    0P 1P 4P 7P 1P
   *     2P 2P 3P       4J 4J 4J 4J  |        0P 0P 0P       0P 1J 6P 0P
   *                       5J 5J     |                          0P 5J
   *                          6P     |                             4J
   *                          7P     |                             1P
   *                          8J     |                             0P
   */

  it('can handle inverted stacks', function() {
    const store = storeWithProfile();
    store.dispatch(changeInvertCallstack(true));
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(
      store.getState()
    );
    expect(stackTimingByDepth).toEqual([
      {
        start: [0, 10, 30, 40, 50, 60, 70, 80, 90],
        end: [10, 30, 40, 50, 60, 70, 80, 90, 91],
        stack: [0, 2, 5, 8, 0, 9, 12, 16, 9],
        length: 9,
      },
      {
        start: [0, 10, 30, 50, 60, 70, 80, 90],
        end: [10, 30, 40, 60, 70, 80, 90, 91],
        stack: [1, 3, 6, 1, 10, 13, 17, 10],
        length: 8,
      },
      {
        start: [10, 30, 60, 70, 80, 90],
        end: [30, 40, 70, 80, 90, 91],
        stack: [4, 7, 11, 14, 18, 11],
        length: 6,
      },
      {
        start: [70, 80],
        end: [80, 90],
        stack: [15, 19],
        length: 2,
      },
      { start: [80], end: [90], stack: [20], length: 1 },
      { start: [80], end: [90], stack: [21], length: 1 },
      { start: [80], end: [90], stack: [22], length: 1 },
    ]);
  });
});

describe('selectors/getCallNodeMaxDepthForFlameChart', function() {
  it('calculates the max func depth and observes of platform-detail filters', function() {
    const store = storeWithProfile();
    const allSamplesMaxDepth = selectedThreadSelectors.getCallNodeMaxDepthForFlameChart(
      store.getState()
    );
    expect(allSamplesMaxDepth).toEqual(6);
    store.dispatch(changeHidePlatformDetails(true));
    const jsOnlySamplesMaxDepth = selectedThreadSelectors.getCallNodeMaxDepthForFlameChart(
      store.getState()
    );
    expect(jsOnlySamplesMaxDepth).toEqual(4);
  });

  it('acts upon the current range', function() {
    const store = storeWithProfile();
    store.dispatch(addRangeFilter(0, 20));
    const allSamplesMaxDepth = selectedThreadSelectors.getCallNodeMaxDepthForFlameChart(
      store.getState()
    );
    expect(allSamplesMaxDepth).toEqual(2);
    store.dispatch(changeHidePlatformDetails(true));
    const jsOnlySamplesMaxDepth = selectedThreadSelectors.getCallNodeMaxDepthForFlameChart(
      store.getState()
    );
    expect(jsOnlySamplesMaxDepth).toEqual(0);
  });
});

describe('selectors/getLeafCategoryStackTimingForFlameChart', function() {
  /**
   * This table shows off how stack timings get filtered to a single row by concurrent
   * color categories. P is platform code, J javascript baseline, and I is javascript
   * interpreter.
   *
   *            Unfiltered             ->      By Concurrent Leaf Category
   *   0-10-20-30-40-50-60-70-80-90-91      0-10-20-30-40-50-60-70-80-90-91 <- Timing (ms)
   *  ================================     ================================
   *  0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |     1P 1P 1P 1P 1P 1P 4J 4J 8I 4J  |
   *  1P 1P 1P 1P    1P 1P 1P 1P 1P  |
   *     2P 2P 3P       4J 4J 4J 4J  |
   *                       5J 5J     |
   *                          6P     |
   *                          7P     |
   *                          8I     |
   */
  it('gets the unfiltered leaf-stack timing by implementation', function() {
    const store = storeWithProfile();
    store.dispatch(changeFlameChartColorStrategy(getCategoryByImplementation));
    const leafStackTiming = selectedThreadSelectors.getLeafCategoryStackTimingForFlameChart(
      store.getState()
    );

    expect(leafStackTiming).toEqual([
      {
        start: [0, 60, 80, 90],
        end: [60, 80, 90, 91],
        stack: [1, 4, 8, 4],
        length: 4,
      },
    ]);
  });
});

describe('actions/changeImplementationFilter', function() {
  const store = storeWithProfile();

  it('is initially set to filter to all', function() {
    const filter = UrlStateSelectors.getImplementationFilter(store.getState());
    expect(filter).toEqual('combined');
  });

  it('can be changed to cpp', function() {
    store.dispatch(changeImplementationFilter('cpp'));
    const filter = UrlStateSelectors.getImplementationFilter(store.getState());
    expect(filter).toEqual('cpp');
  });
});

describe('actions/updateProfileSelection', function() {
  it('can update the selection with new values', function() {
    const store = storeWithProfile();

    const initialSelection = ProfileViewSelectors.getProfileViewOptions(
      store.getState()
    ).selection;
    expect(initialSelection).toEqual({
      hasSelection: false,
      isModifying: false,
    });

    store.dispatch(
      updateProfileSelection({
        hasSelection: true,
        isModifying: false,
        selectionStart: 100,
        selectionEnd: 200,
      })
    );

    const secondSelection = ProfileViewSelectors.getProfileViewOptions(
      store.getState()
    ).selection;
    expect(secondSelection).toEqual({
      hasSelection: true,
      isModifying: false,
      selectionStart: 100,
      selectionEnd: 200,
    });
  });
});

describe('selectors/getMarkerTiming', function() {
  function getMarkerTiming(testMarkers) {
    const profile = getProfileWithMarkers(testMarkers);
    const { getState } = storeWithProfile(profile);
    return selectedThreadSelectors.getMarkerTiming(getState());
  }

  it('has no marker timing if no markers are present', function() {
    expect(getMarkerTiming([])).toEqual([]);
  });

  describe('markers of the same name', function() {
    it('puts markers of the same time in two rows', function() {
      // The timing should look like this:
      // 'Marker Name': *------*
      //              : *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, { startTime: 0, endTime: 10 }],
        ['Marker Name', 0, { startTime: 0, endTime: 10 }],
      ]);
      expect(markerTiming).toHaveLength(2);
    });

    it('puts markers of disjoint times in one row', function() {
      // The timing should look like this:
      // 'Marker Name': *------*  *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, { startTime: 0, endTime: 10 }],
        ['Marker Name', 0, { startTime: 15, endTime: 25 }],
      ]);
      expect(markerTiming).toHaveLength(1);
    });

    it('puts markers of overlapping times in two rows', function() {
      // The timing should look like this:
      // 'Marker Name': *------*
      //              :     *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, { startTime: 0, endTime: 10 }],
        ['Marker Name', 0, { startTime: 5, endTime: 15 }],
      ]);
      expect(markerTiming).toHaveLength(2);
    });

    it('puts markers of inclusive overlapping times in two rows', function() {
      // The timing should look like this:
      // 'Marker Name': *--------*
      //              :   *---*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, { startTime: 0, endTime: 20 }],
        ['Marker Name', 0, { startTime: 5, endTime: 15 }],
      ]);
      expect(markerTiming).toHaveLength(2);
    });
  });

  describe('markers of the different names', function() {
    it('puts them in different rows', function() {
      // The timing should look like this:
      // 'Marker Name A': *------*
      // 'Marker Name B':           *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name A', 0, { startTime: 0, endTime: 10 }],
        ['Marker Name B', 0, { startTime: 20, endTime: 30 }],
      ]);
      expect(markerTiming).toHaveLength(2);
      expect(markerTiming[0].name).toBe('Marker Name A');
      expect(markerTiming[1].name).toBe('Marker Name B');
    });
  });
});
